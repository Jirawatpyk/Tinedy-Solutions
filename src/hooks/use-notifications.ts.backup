import { useEffect, useState } from 'react'
import { supabase } from '@/lib/supabase'
import { useAuth } from '@/contexts/auth-context'
import { notificationService } from '@/lib/notifications'
import type { RealtimePostgresChangesPayload } from '@supabase/supabase-js'
import { format } from 'date-fns'

// Types for Supabase realtime payloads
interface BookingPayload {
  id: string
  customer_id: string
  staff_id: string | null
  team_id: string | null
  booking_date: string
  start_time: string
  end_time: string
  status: string
}

interface BookingWithCustomer {
  id: string
  start_time: string
  end_time: string
  staff_id: string | null
  team_id: string | null
  customers: { full_name: string } | { full_name: string }[] | null
}

// ============================================================================
// NOTIFICATION HELPERS
// ============================================================================

/**
 * Format booking date for notifications (e.g., "23 Nov")
 */
function formatBookingDate(dateString: string): string {
  try {
    return format(new Date(dateString), 'dd MMM')
  } catch (error) {
    console.error('[Notifications] Error formatting date:', error)
    return dateString
  }
}

// ============================================================================
// NOTIFICATION PREFERENCE HELPERS
// ============================================================================

const NOTIFICATION_PROMPT_HIDDEN_KEY = 'notification_prompt_hidden'

/**
 * Check if user has hidden the notification prompt
 */
export function isNotificationPromptHidden(userId: string): boolean {
  try {
    const key = `${NOTIFICATION_PROMPT_HIDDEN_KEY}_${userId}`
    const value = localStorage.getItem(key)
    return value === 'true'
  } catch {
    return false
  }
}

/**
 * Set notification prompt hidden preference
 */
export function setNotificationPromptHidden(userId: string, hidden: boolean): void {
  try {
    const key = `${NOTIFICATION_PROMPT_HIDDEN_KEY}_${userId}`
    if (hidden) {
      localStorage.setItem(key, 'true')
    } else {
      localStorage.removeItem(key)
    }
  } catch (err) {
    console.error('[Notifications] Error saving prompt preference:', err)
  }
}

export function useNotifications() {
  const { user } = useAuth()
  // Use lazy initialization to check permission immediately
  const [hasPermission, setHasPermission] = useState(() => {
    try {
      const granted = notificationService.isGranted()
      console.log('[Notifications] üîî Initial Permission Check:', {
        granted,
        browserPermission: typeof Notification !== 'undefined' ? Notification.permission : 'N/A'
      })
      return granted
    } catch (error) {
      console.error('[Notifications] ‚ùå Error checking initial permission:', error)
      return false
    }
  })
  const [isRequesting, setIsRequesting] = useState(false)
  const [myTeamIds, setMyTeamIds] = useState<string[]>([])

  // Load team IDs that this user belongs to
  useEffect(() => {
    if (!user) return

    const loadMyTeams = async () => {
      try {
        // Get teams where user is a member
        const { data: memberTeams } = await supabase
          .from('team_members')
          .select('team_id')
          .eq('staff_id', user.id)
          .eq('is_active', true)

        // Get teams where user is the lead
        const { data: leadTeams } = await supabase
          .from('teams')
          .select('id')
          .eq('team_lead_id', user.id)
          .eq('is_active', true)

        const memberTeamIds = memberTeams?.map(m => m.team_id) || []
        const leadTeamIds = leadTeams?.map(t => t.id) || []

        // Combine and deduplicate
        const allTeamIds = [...new Set([...memberTeamIds, ...leadTeamIds])]
        setMyTeamIds(allTeamIds)

        console.log('[Notifications] User belongs to teams:', allTeamIds)
      } catch (err) {
        console.error('[Notifications] Error loading teams:', err)
      }
    }

    loadMyTeams()
  }, [user])

  // Request permission from user
  const requestPermission = async () => {
    setIsRequesting(true)
    const granted = await notificationService.requestPermission()
    setHasPermission(granted)
    setIsRequesting(false)
    return granted
  }

  // Listen for new bookings assigned to this staff OR their teams
  useEffect(() => {
    if (!user) {
      console.log('[Notifications] ‚ö†Ô∏è No user, skipping realtime setup')
      return
    }

    if (!hasPermission) {
      console.log('[Notifications] ‚ö†Ô∏è No permission granted, skipping realtime setup')
      return
    }

    console.log('[Notifications] ‚úÖ Setting up realtime listener:', {
      staffId: user.id,
      email: user.email,
      myTeams: myTeamIds,
      hasPermission
    })

    const channel = supabase
      .channel('staff-notifications')
      .on<BookingPayload>(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'bookings',
        },
        async (payload: RealtimePostgresChangesPayload<BookingPayload>) => {
          const booking = payload.new as BookingPayload

          console.log('[Notifications] üì• INSERT event received:', {
            event: payload.eventType,
            bookingId: booking?.id,
            timestamp: new Date().toISOString()
          })

          // Check if this booking is relevant to current user
          const isMyBooking = booking.staff_id === user.id
          const isMyTeamBooking = booking.team_id && myTeamIds.includes(booking.team_id)

          console.log('[Notifications] üîç Relevance check:', {
            bookingStaffId: booking.staff_id,
            bookingTeamId: booking.team_id,
            currentUserId: user.id,
            myTeams: myTeamIds,
            isMyBooking,
            isMyTeamBooking
          })

          if (!isMyBooking && !isMyTeamBooking) {
            console.log('[Notifications] ‚è≠Ô∏è Skipping - not relevant to this user')
            return // Not relevant to this user
          }

          // Fetch customer details
          const { data: customerData } = await supabase
            .from('customers')
            .select('full_name')
            .eq('id', booking.customer_id)
            .single()

          const customerName = customerData?.full_name || 'Customer'
          const time = `${booking.start_time.slice(0, 5)} - ${booking.end_time.slice(0, 5)}`
          const bookingDate = formatBookingDate(booking.booking_date)

          // Determine notification type
          const notificationType = isMyTeamBooking && !isMyBooking ? 'team' : 'personal'

          console.log('[Notifications] üíæ Saving notification:', {
            type: notificationType,
            customer: customerName,
            date: bookingDate,
            time
          })

          // Save to in-app notifications
          const { error: insertError } = await supabase.from('notifications').insert({
            user_id: user.id,
            type: notificationType === 'team' ? 'team_booking' : 'new_booking',
            title: notificationType === 'team' ? 'üë• New Team Booking!' : 'üîî New Booking!',
            message: notificationType === 'team'
              ? `New team booking from ${customerName} on ${bookingDate} at ${time}`
              : `New booking from ${customerName} on ${bookingDate} at ${time}`,
            booking_id: booking.id,
            team_id: booking.team_id || null,
          })

          if (insertError) {
            console.error('[Notifications] ‚ùå Error saving notification:', insertError)
          } else {
            console.log('[Notifications] ‚úÖ Notification saved successfully!')
          }

          // Show browser notification
          console.log('[Notifications] üîî Showing browser notification...')
          await notificationService.notifyNewBooking(
            customerName,
            time,
            booking.id,
            notificationType
          )
          console.log('[Notifications] ‚úÖ Browser notification shown!')
        }
      )
      .on<BookingPayload>(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'bookings',
        },
        async (payload: RealtimePostgresChangesPayload<BookingPayload>) => {
          const oldBooking = payload.old as BookingPayload
          const newBooking = payload.new as BookingPayload

          console.log('[Notifications] üì• UPDATE event received:', {
            event: payload.eventType,
            bookingId: newBooking.id,
            oldStaffId: oldBooking.staff_id,
            newStaffId: newBooking.staff_id,
            oldTeamId: oldBooking.team_id,
            newTeamId: newBooking.team_id,
            oldStatus: oldBooking.status,
            newStatus: newBooking.status,
            timestamp: new Date().toISOString()
          })

          // Check if staff/team was just assigned to current user
          // Assignment = staff_id CHANGED from "not me" to "me"
          const wasJustAssignedToMe =
            oldBooking.staff_id !== newBooking.staff_id &&  // staff_id CHANGED
            oldBooking.staff_id !== user.id &&              // Was NOT assigned to me before
            newBooking.staff_id === user.id                  // Now IS assigned to me

          // Team assignment = team_id CHANGED from "not my team" to "my team"
          const wasJustAssignedToMyTeam =
            oldBooking.team_id !== newBooking.team_id &&    // team_id CHANGED
            (!oldBooking.team_id || !myTeamIds.includes(oldBooking.team_id)) &&  // Was NOT my team before
            newBooking.team_id &&
            myTeamIds.includes(newBooking.team_id)          // Now IS my team

          console.log('[Notifications] üîç Assignment check:', {
            wasJustAssignedToMe,
            wasJustAssignedToMyTeam,
            oldStaffId: oldBooking.staff_id,
            newStaffId: newBooking.staff_id,
            currentUserId: user.id,
            oldTeamId: oldBooking.team_id,
            newTeamId: newBooking.team_id,
            myTeamIds,
            condition1: `oldStaffId (${oldBooking.staff_id}) !== userId (${user.id}) = ${oldBooking.staff_id !== user.id}`,
            condition2: `newStaffId (${newBooking.staff_id}) === userId (${user.id}) = ${newBooking.staff_id === user.id}`
          })

          // Check if this booking is relevant to current user
          const isMyBooking = newBooking.staff_id === user.id
          const isMyTeamBooking = newBooking.team_id && myTeamIds.includes(newBooking.team_id)

          console.log('[Notifications] üîç Relevance check:', {
            isMyBooking,
            isMyTeamBooking,
            bookingStaffId: newBooking.staff_id,
            bookingTeamId: newBooking.team_id
          })

          if (!isMyBooking && !isMyTeamBooking) {
            console.log('[Notifications] ‚è≠Ô∏è Skipping - not relevant to this user')
            return // Not relevant to this user
          }

          const { data: customerData} = await supabase
            .from('customers')
            .select('full_name')
            .eq('id', newBooking.customer_id)
            .single()

          const customerName = customerData?.full_name || 'Customer'
          const time = `${newBooking.start_time.slice(0, 5)} - ${newBooking.end_time.slice(0, 5)}`
          const bookingDate = formatBookingDate(newBooking.booking_date)
          const notificationType = isMyTeamBooking && !isMyBooking ? 'team' : 'personal'

          // Notify if staff/team was just assigned
          if (wasJustAssignedToMe || wasJustAssignedToMyTeam) {
            console.log('[Notifications] üéØ New assignment detected!')

            // Save to in-app notifications
            const { error: assignError } = await supabase.from('notifications').insert({
              user_id: user.id,
              type: wasJustAssignedToMyTeam ? 'team_booking' : 'booking_assigned',
              title: wasJustAssignedToMyTeam ? 'üë• New Team Booking Assigned!' : 'üìå New Booking Assigned to You!',
              message: wasJustAssignedToMyTeam
                ? `New team booking from ${customerName} on ${bookingDate} at ${time}`
                : `You have been assigned a booking with ${customerName} on ${bookingDate} at ${time}`,
              booking_id: newBooking.id,
              team_id: newBooking.team_id || null,
            })

            if (assignError) {
              console.error('[Notifications] Error saving assignment notification:', assignError)
            } else {
              console.log('[Notifications] ‚úÖ Assignment notification saved!')
            }

            // Show browser notification
            await notificationService.show({
              title: wasJustAssignedToMyTeam ? 'üë• New Team Booking Assigned!' : 'üìå New Booking Assigned!',
              body: wasJustAssignedToMyTeam
                ? `New team booking from ${customerName} at ${time}`
                : `You have been assigned to ${customerName} at ${time}`,
              tag: `assignment-${newBooking.id}`,
              data: {
                type: 'booking_assigned',
                bookingId: newBooking.id,
                url: '/staff'
              }
            })

            console.log('[Notifications] üîî Assignment browser notification sent!')
          }

          // Notify if booking was cancelled
          if (oldBooking.status !== 'cancelled' && newBooking.status === 'cancelled') {
            // Save to in-app notifications
            await supabase.from('notifications').insert({
              user_id: user.id,
              type: 'booking_cancelled',
              title: notificationType === 'team' ? 'üë• Team Booking Cancelled' : '‚ùå Booking Cancelled',
              message: notificationType === 'team'
                ? `Team booking with ${customerName} on ${bookingDate} at ${time} was cancelled`
                : `Booking with ${customerName} on ${bookingDate} at ${time} was cancelled`,
              booking_id: newBooking.id,
              team_id: newBooking.team_id || null,
            })

            await notificationService.notifyBookingCancelled(customerName, time, notificationType)
          }

          // Notify if status changed (confirmed -> in_progress -> completed)
          if (oldBooking.status !== newBooking.status && newBooking.status !== 'cancelled') {
            const statusMap: Record<string, string> = {
              confirmed: 'Confirmed',
              in_progress: 'In Progress',
              completed: 'Completed',
            }
            const statusText = statusMap[newBooking.status] || newBooking.status

            const emojiMap: Record<string, string> = {
              confirmed: '‚úÖ',
              in_progress: 'üîÑ',
              completed: '‚ú®',
            }
            const statusEmoji = emojiMap[newBooking.status] || 'üìù'

            console.log('[Notifications] üíæ Saving status update notification:', {
              booking_id: newBooking.id,
              customer: customerName,
              status: statusText,
              hasBookingId: !!newBooking.id
            })

            // Save to in-app notifications
            const { error: statusError } = await supabase.from('notifications').insert({
              user_id: user.id,
              type: 'booking_updated',
              title: notificationType === 'team' ? 'üë• Team Booking Status Updated' : `${statusEmoji} Booking Status Updated`,
              message: notificationType === 'team'
                ? `Team booking with ${customerName} on ${bookingDate} at ${time} ‚Üí ${statusText}`
                : `Booking with ${customerName} on ${bookingDate} at ${time} ‚Üí ${statusText}`,
              booking_id: newBooking.id,
              team_id: newBooking.team_id || null,
            })

            if (statusError) {
              console.error('[Notifications] ‚ùå Error saving status notification:', statusError)
            } else {
              console.log('[Notifications] ‚úÖ Status notification saved with booking_id:', newBooking.id)
            }

            // Show browser notification
            await notificationService.show({
              title: notificationType === 'team' ? 'üë• Team Booking Status Updated' : `${statusEmoji} Booking Status Updated`,
              body: notificationType === 'team'
                ? `Team booking with ${customerName} at ${time} ‚Üí ${statusText}`
                : `Booking with ${customerName} at ${time} ‚Üí ${statusText}`,
              tag: `status-update-${newBooking.id}`,
              data: {
                type: 'booking_updated',
                bookingId: newBooking.id,
                url: '/staff'
              }
            })
          }
        }
      )
      .subscribe((status) => {
        console.log('[Notifications] üì° Channel status:', status)
        if (status === 'SUBSCRIBED') {
          console.log('[Notifications] ‚úÖ Successfully subscribed to realtime updates!')
        } else if (status === 'CHANNEL_ERROR') {
          console.error('[Notifications] ‚ùå Channel error!')
        } else if (status === 'TIMED_OUT') {
          console.error('[Notifications] ‚è±Ô∏è Subscription timed out!')
        }
      })

    return () => {
      console.log('[Notifications] üßπ Cleaning up realtime listener')
      supabase.removeChannel(channel)
    }
  }, [user, hasPermission, myTeamIds])

  // Schedule reminder notifications for upcoming bookings (personal + team)
  useEffect(() => {
    if (!user || !hasPermission) return

    const scheduleReminders = async () => {
      const now = new Date()
      const in30Minutes = new Date(now.getTime() + 30 * 60 * 1000)
      const in35Minutes = new Date(now.getTime() + 35 * 60 * 1000)

      const todayStr = now.toISOString().split('T')[0]
      const timeStr = in30Minutes.toTimeString().slice(0, 5)
      const endTimeStr = in35Minutes.toTimeString().slice(0, 5)

      // Find bookings starting in ~30 minutes (personal + team)
      let query = supabase
        .from('bookings')
        .select(`
          id,
          start_time,
          end_time,
          staff_id,
          team_id,
          customers (full_name)
        `)
        .eq('booking_date', todayStr)
        .eq('status', 'confirmed')
        .gte('start_time', timeStr)
        .lte('start_time', endTimeStr)

      // Filter for personal OR team bookings
      if (myTeamIds.length > 0) {
        query = query.or(`staff_id.eq.${user.id},team_id.in.(${myTeamIds.join(',')})`)
      } else {
        query = query.eq('staff_id', user.id)
      }

      const { data: upcomingBookings } = await query

      if (upcomingBookings && upcomingBookings.length > 0) {
        for (const booking of upcomingBookings as BookingWithCustomer[]) {
          const customerName = Array.isArray(booking.customers)
            ? booking.customers[0]?.full_name || 'Customer'
            : booking.customers?.full_name || 'Customer'
          const time = `${booking.start_time.slice(0, 5)}`

          const isMyBooking = booking.staff_id === user.id
          const isMyTeamBooking = booking.team_id && myTeamIds.includes(booking.team_id)
          const notificationType = isMyTeamBooking && !isMyBooking ? 'team' : 'personal'

          // Save to in-app notifications
          await supabase.from('notifications').insert({
            user_id: user.id,
            type: 'booking_reminder',
            title: notificationType === 'team' ? 'üë• Team Booking Reminder' : '‚è∞ Booking Reminder',
            message: notificationType === 'team'
              ? `Team booking with ${customerName} starts in 30 minutes (${time})`
              : `Booking with ${customerName} starts in 30 minutes (${time})`,
            booking_id: booking.id,
            team_id: booking.team_id || null,
          })

          await notificationService.notifyBookingReminder(
            customerName,
            time,
            booking.id,
            notificationType
          )
        }
      }
    }

    // Check every 5 minutes
    const interval = setInterval(scheduleReminders, 5 * 60 * 1000)

    // Check immediately
    scheduleReminders()

    return () => clearInterval(interval)
  }, [user, hasPermission, myTeamIds])

  return {
    hasPermission,
    isRequesting,
    requestPermission,
    isSupported: notificationService.isSupported(),
  }
}
